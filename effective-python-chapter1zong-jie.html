<!DOCTYPE html>
<html lang="zh">
  <head>
        <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=endge, chrome=IE8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width, user-scalable=no" />
    <title>《Effective Python》Chapter1总结 — /usr/bin/sysublackbear</title>
    <!--[if lte IE 8]><script type="text/javascript" src="/theme/js/html5shiv.js"></script><![endif]-->
    <link rel="stylesheet" type="text/css" href="/theme/css/skeleton.css" />
    <link rel="stylesheet" type="text/css" href="/theme/css/theme.css" />
    <link rel="shortcut icon" type="image/png" href="/favicon.png" />
    <!--[if lte IE 8]><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" /><![endif]-->
    <link rel="alternate" type="application/atom+xml"
                           title="/usr/bin/sysublackbear — Flux Atom"
                           href="/" /> 

    <meta name="author"   content="sysublackbear" />
    <meta name="keywords" content="python" />
    <link rel="stylesheet" media="not print" type="text/css" href="/theme/css/pygments.css" /> 
  </head>
  <body>
    <div id="page">
      <header id="page-head">
        <h1>
          <a href="/index.html">/usr/bin/sysublackbear</a>
        </h1>
      </header>
      
      <div id="page-body">
        <article class="post" id="page-main" role="main">
      <header class="post-header">
        <h1>
          <a rel="bookmark"
             href="/effective-python-chapter1zong-jie.html"
             title="Lien permanent vers «《Effective Python》Chapter1总结»">
             《Effective Python》Chapter1总结
          </a>
        </h1>
        <div class="meta">
<!-- includes/article_meta.html -->
Date: <time datetime="2016-10-30T23:39:00+08:00">日 30 十月 2016</time><br />
Categories: <a href="/category/python.html">python</a><br />
Author: <a href="/author/sysublackbear.html">sysublackbear</a>              <br />Tags:              <a rel="tag" href="/tag/python.html">python</a>        </div>
      </header>
      <div class="post-content"> 
        <p>最近在看《Effective Python》这本书，觉得很不错，对于今后的代码如何写得更pythonic。整理下吧，后面可以反复看，感觉很多建议都非常实用。</p>
<p>下面是一些重点摘要：</p>
<h1>Chapter1.用Pythonic 方式来思考</h1>
<h4>第1条：确认自己所用的Python 版本</h4>
<p>没什么可说的，还是尽快把代码迁往py3.x吧，顺便写下如何了解所使用的具体版本python：</p>
<div class="highlight"><pre><span></span><span class="err">➜</span>  <span class="o">~</span> <span class="n">python</span> <span class="o">--</span><span class="n">version</span>
<span class="n">Python</span> <span class="mf">2.7</span><span class="o">.</span><span class="mi">10</span>
<span class="err">➜</span>  <span class="o">~</span> <span class="n">python3</span> <span class="o">--</span><span class="n">version</span>
<span class="n">Python</span> <span class="mf">3.5</span><span class="o">.</span><span class="mi">0</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>
</pre></div>


<ul>
<li>有两种版本的Python处于活跃的状态：python2 和 python3；</li>
<li>有多种流行的Python运行时环境，例如：CPython，Jython，IronPython 以及 PyPy等。</li>
</ul>
<h4>第2条：遵循PEP8风格指南</h4>
<p>整理下值得注意的PEP8规则吧：</p>
<p><strong>空白</strong>：</p>
<ul>
<li>使用space（空格）来表示缩进，而不要用tab（制表符）；</li>
<li>一个缩进都用4个空格来表示；</li>
</ul>
<p><strong>命名</strong>：</p>
<ul>
<li>函数，变量及属性应该用小写字母来拼写，各单词之间以下划线相连，例如：lowercase_underscore；</li>
<li>受保护的实例属性，应该以单个下划线开头，例如：_leading_underscore;</li>
<li>私有的实例属性，应该以两个下划线开头，例如：__double_leading_underscore;</li>
<li>类与异常，应该以每个单词首字母均大写的形式来命名。例如：CapitailizedWord；</li>
<li>模块级别的常量，应该全部采用大写字母来拼写，各单词之间以下划线相连，例如：ALL_CAPS；</li>
<li>类中的实例方法（instance method），应该把首个参数命名为self，以表示该对象自身；</li>
<li>类方法（class method）的首个参数，应该命名为cls，以表示该类自身。</li>
</ul>
<p><strong>表达式和语句</strong></p>
<ul>
<li>import 语句应该总是放在文件开头；</li>
<li>引入模块的时候，总是应该使用绝对名称，而不应该根据当前模块的路径来使用相对名称。例如，引入bar包中的foo模块时，应该完整地写出from bar import foo。</li>
<li>如果一定要以相对名称来编写import 语句，那就采用明确的写法，from . import foo;</li>
<li>文件中的那些 import 语句应该按顺序划分成三个部分，分别表示<strong>标准库模块</strong>，<strong>第三方模块</strong>以及<strong>自用模块</strong>。在每一部分之中，各import 语句应该按模块的字母顺序来排列。</li>
</ul>
<p>总而言之，用PyCharm吧，按照PEP8进行规范提示的。</p>
<h4>第3条：了解bytes，str与unicode 的区别</h4>
<p>感觉对目前我应用的场景不多，用的都是str，列下要点吧，按需深刻了解：</p>
<ul>
<li>在python3中，bytes是一种包含8位值的序列，str是一种包含Unicode字符的序列。开发者不能以&gt; 或+ 等操作符来混同操作bytes 和str 实例。</li>
<li>在python2中，str是一种包含8位值的序列，unicode是一种包含Unicode字符的序列。如果str只含有7位ASCII字符，那么可以通过相关的操作符来同时使用str 与 unicode。</li>
</ul>
<h4>第4条：用辅助函数来取代复杂的表达式，而不是一味一行式来表示所有的逻辑</h4>
<p>举个例子：要从URL 中解码查询字符串。每个参数都可以表示一个整数：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">parse_qs</span>

<span class="n">my_values</span> <span class="o">=</span> <span class="n">parse_qs</span><span class="p">(</span><span class="s1">&#39;red=5&amp;blue=0&amp;green=&#39;</span><span class="p">,</span> <span class="n">keep_blank_values</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">my_values</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;red&#39;</span><span class="p">:[</span><span class="s1">&#39;5&#39;</span><span class="p">],</span> <span class="s1">&#39;green&#39;</span><span class="p">:[</span><span class="s1">&#39;&#39;</span><span class="p">],</span> <span class="s1">&#39;blue&#39;</span><span class="p">:[</span><span class="s1">&#39;0&#39;</span><span class="p">]}</span>
</pre></div>


<p>如果我们想要对于空值或者不存在的值统一返回默认值0，怎么处理比较好？</p>
<p>可以使用一行式表示，用or操作进行逻辑短路开关作用，但这样可读性很差：</p>
<div class="highlight"><pre><span></span><span class="n">red</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">my_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1"># or操作符的作用：如果or前半段为true的话，后面的逻辑不会再走</span>
</pre></div>


<p>也可以使用三元表达式来表示，提高可读性：</p>
<div class="highlight"><pre><span></span><span class="n">red</span> <span class="o">=</span> <span class="n">my_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">])</span>
<span class="n">red</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">red</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
</pre></div>


<p>所以可以总结成辅助函数了，如果频繁使用这种逻辑，就更应该抽出来封成函数：</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_first_int</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">found</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">found</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">found</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">found</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">found</span> <span class="o">=</span> <span class="n">default</span>
    <span class="k">return</span> <span class="n">found</span>

<span class="n">red</span> <span class="o">=</span> <span class="n">get_first_int</span><span class="p">(</span><span class="n">my_values</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
</pre></div>


<p>由此得到要点：</p>
<ul>
<li>开发者很容易过度运用Python的语法特性，从而写出那种特别复杂并且难以理解的单行表达式。</li>
<li>请把复杂的表达式移入辅助函数之中，如果要反复使用相同的逻辑，那就更应该这么做。</li>
<li>使用 if / else 表达式，要比用 or 或 and 这样的 Boolean 操作符写成的表达式更加清晰。</li>
</ul>
<h4>第5条：了解切割序列的办法</h4>
<p><strong>要点</strong>：</p>
<ul>
<li>不要写多余的代码：当start 索引为0，或end索引为序列长度时，应该将其省略；</li>
<li>切片操作不会计较start 与 end索引是否越界，这使得我们很容易就能从序列的前端或后端开始，对其进行范围固定的切片操作（如 a[:20] 与 a[-20:]）。</li>
<li>对list 赋值的时候，如果使用切片操作，就会把原列表中处在相关范围内的值替换成新值，即便它们的长度不同也依然可以替换。</li>
</ul>
<h4>第6条：在单次切片操作内，不要同时指定start，end 和 stride</h4>
<p><strong>要点：</strong></p>
<ul>
<li>既有start 和end， 又有stride 的切割操作，可能会令人费解。</li>
<li>尽量使用stride 为正数，且不带 start 或end 索引的切割操作。尽量避免用负数做stride。</li>
<li>在同一个切片操作内，不要同时使用start， end和 stride。如果确实需要执行这种操作，那就考虑将其拆解为两条赋值语句，其中一条做<strong>范围切割</strong>，另一条做<strong>步进切割</strong>，如果使用的开发程序对执行的时间或者内存用量的要求非常严格，以致不能采用两阶段切割法，那就请考虑使用内置的itertool模块中的 islice，创建的是迭代器。</li>
</ul>
<h4>第7条：用列表推导式来取代map和 filter</h4>
<p>列表推导式与map和filter之间的比较：</p>
<p>列表推导式：</p>
<div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">even_squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>


<p>map 和 filter函数的组合：</p>
<div class="highlight"><pre><span></span><span class="n">alt</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
</pre></div>


<p>可见：</p>
<ul>
<li>列表推导要比内置的map 和filter 函数清晰，因为它无需额外编写lambda 表达式；</li>
<li>列表推导可以跳过输入列表中的某些元素，如果改用map来做，那就必须辅以 filter 方能实现；</li>
<li>字典与集也支持推导表达式。</li>
</ul>
<h4>第8条：不要使用含有两个以上表达式的列表推导</h4>
<p><strong>要点：</strong></p>
<ul>
<li>列表推导支持多级循环，每一级循环也支持多项条件；</li>
</ul>
      </div>
      <footer class="post-footer">
        <div class="meta">
          Article Categories: <a href="/category/python.html">python</a><br /> 
          Author Articles: <a href="/author/sysublackbear.html">sysublackbear</a><br />
          Article Tags:  #<a href="/tag/python.html">python</a>        </div>
      </footer>
      </article> <!-- /#page-main -->

        <aside id="page-side">
          <!-- begin includes/sidebar.html -->
          <nav>
            <h3>个人主页</h3>
            <ul>
              <li><a href="/categories.html">Categories</a></li>
              <li><a href="/archives.html">Archives</a></li>
              <li><a href="/tags.html">Tags</a></li>
            </ul>
          </nav>

          <nav>
            <h3>类别</h3>
            <ul>
              <li><a href="/category/about-me.html">about me</a></li>
              <li><a href="/category/c.html">C++</a></li>
              <li><a href="/category/code.html">code</a></li>
              <li><a href="/category/jia-gou-mo-shi.html">架构模式</a></li>
              <li><a href="/category/pelican.html">pelican</a></li>
              <li class="active"><a href="/category/python.html">python</a></li>
            </ul>
          </nav>

          <nav>
            <h3>链接</h3>
            <ul>
              <li><a href="https://www.zhihu.com/people/sysublackbear">知乎</a></li>
              <li><a href="http://www.cnblogs.com/sysu-blackbear">博客园</a></li>
              <li><a href="http://weibo.com/sysublackbear?is_all=1">新浪微博</a></li>
            </ul>
          </nav>
          <!-- end includes/sidebar.html --></aside> <!-- /#page-side -->
      </div>  <!-- /#page-body -->

      <footer id="page-foot">
        <p> Powered by <a href="http://pelican.readthedocs.org">Pelican</a></p>
      </footer>
    </div> <!-- /#page -->
  </body>
</html>