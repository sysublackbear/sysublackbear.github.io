<!DOCTYPE html>
<html lang="zh">
  <head>
        <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=endge, chrome=IE8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width, user-scalable=no" />
    <title>《Effective Python》Chapter1总结 — /usr/bin/sysublackbear</title>
    <!--[if lte IE 8]><script type="text/javascript" src="/theme/js/html5shiv.js"></script><![endif]-->
    <link rel="stylesheet" type="text/css" href="/theme/css/skeleton.css" />
    <link rel="stylesheet" type="text/css" href="/theme/css/theme.css" />
    <link rel="shortcut icon" type="image/png" href="/favicon.png" />
    <!--[if lte IE 8]><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" /><![endif]-->
    <link rel="alternate" type="application/atom+xml"
                           title="/usr/bin/sysublackbear — Flux Atom"
                           href="/" /> 

    <meta name="author"   content="sysublackbear" />
    <meta name="keywords" content="python" />
    <link rel="stylesheet" media="not print" type="text/css" href="/theme/css/pygments.css" /> 
  </head>
  <body>
    <div id="page">
      <header id="page-head">
        <h1>
          <a href="/index.html">/usr/bin/sysublackbear</a>
        </h1>
      </header>
      
      <div id="page-body">
        <article class="post" id="page-main" role="main">
      <header class="post-header">
        <h1>
          <a rel="bookmark"
             href="/effective-python-chapter1zong-jie.html"
             title="Lien permanent vers «《Effective Python》Chapter1总结»">
             《Effective Python》Chapter1总结
          </a>
        </h1>
        <div class="meta">
<!-- includes/article_meta.html -->
Date: <time datetime="2016-10-30T23:39:00+08:00">日 30 十月 2016</time><br />
Categories: <a href="/category/python.html">python</a><br />
Author: <a href="/author/sysublackbear.html">sysublackbear</a>              <br />Tags:              <a rel="tag" href="/tag/python.html">python</a>        </div>
      </header>
      <div class="post-content"> 
        <p>最近在看《Effective Python》这本书，觉得很不错，对于今后的代码如何写得更pythonic。整理下吧，后面可以反复看，感觉很多建议都非常实用。</p>
<p>下面是一些重点摘要：</p>
<h1>Chapter1.用Pythonic 方式来思考</h1>
<h4>第1条：确认自己所用的Python 版本</h4>
<p>没什么可说的，还是尽快把代码迁往py3.x吧，顺便写下如何了解所使用的具体版本python：</p>
<div class="highlight"><pre><span></span><span class="err">➜</span>  <span class="o">~</span> <span class="n">python</span> <span class="o">--</span><span class="n">version</span>
<span class="n">Python</span> <span class="mf">2.7</span><span class="o">.</span><span class="mi">10</span>
<span class="err">➜</span>  <span class="o">~</span> <span class="n">python3</span> <span class="o">--</span><span class="n">version</span>
<span class="n">Python</span> <span class="mf">3.5</span><span class="o">.</span><span class="mi">0</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>
</pre></div>


<ul>
<li>有两种版本的Python处于活跃的状态：python2 和 python3；</li>
<li>有多种流行的Python运行时环境，例如：CPython，Jython，IronPython 以及 PyPy等。</li>
</ul>
<h4>第2条：遵循PEP8风格指南</h4>
<p>整理下值得注意的PEP8规则吧：</p>
<p><strong>空白</strong>：</p>
<ul>
<li>使用space（空格）来表示缩进，而不要用tab（制表符）；</li>
<li>一个缩进都用4个空格来表示；</li>
</ul>
<p><strong>命名</strong>：</p>
<ul>
<li>函数，变量及属性应该用小写字母来拼写，各单词之间以下划线相连，例如：lowercase_underscore；</li>
<li>受保护的实例属性，应该以单个下划线开头，例如：_leading_underscore;</li>
<li>私有的实例属性，应该以两个下划线开头，例如：__double_leading_underscore;</li>
<li>类与异常，应该以每个单词首字母均大写的形式来命名。例如：CapitailizedWord；</li>
<li>模块级别的常量，应该全部采用大写字母来拼写，各单词之间以下划线相连，例如：ALL_CAPS；</li>
<li>类中的实例方法（instance method），应该把首个参数命名为self，以表示该对象自身；</li>
<li>类方法（class method）的首个参数，应该命名为cls，以表示该类自身。</li>
</ul>
<p><strong>表达式和语句</strong></p>
<ul>
<li>import 语句应该总是放在文件开头；</li>
<li>引入模块的时候，总是应该使用绝对名称，而不应该根据当前模块的路径来使用相对名称。例如，引入bar包中的foo模块时，应该完整地写出from bar import foo。</li>
<li>如果一定要以相对名称来编写import 语句，那就采用明确的写法，from . import foo;</li>
<li>文件中的那些 import 语句应该按顺序划分成三个部分，分别表示<strong>标准库模块</strong>，<strong>第三方模块</strong>以及<strong>自用模块</strong>。在每一部分之中，各import 语句应该按模块的字母顺序来排列。</li>
</ul>
<p>总而言之，用PyCharm吧，按照PEP8进行规范提示的。</p>
<h4>第3条：了解bytes，str与unicode 的区别</h4>
<p>感觉对目前我应用的场景不多，用的都是str，列下要点吧，按需深刻了解：</p>
<ul>
<li>在python3中，bytes是一种包含8位值的序列，str是一种包含Unicode字符的序列。开发者不能以&gt; 或+ 等操作符来混同操作bytes 和str 实例。</li>
<li>在python2中，str是一种包含8位值的序列，unicode是一种包含Unicode字符的序列。如果str只含有7位ASCII字符，那么可以通过相关的操作符来同时使用str 与 unicode。</li>
</ul>
<h4>第4条：用辅助函数来取代复杂的表达式，而不是一味一行式来表示所有的逻辑</h4>
<p>举个例子：要从URL 中解码查询字符串。每个参数都可以表示一个整数：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">parse_qs</span>

<span class="n">my_values</span> <span class="o">=</span> <span class="n">parse_qs</span><span class="p">(</span><span class="s1">&#39;red=5&amp;blue=0&amp;green=&#39;</span><span class="p">,</span> <span class="n">keep_blank_values</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">my_values</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;red&#39;</span><span class="p">:[</span><span class="s1">&#39;5&#39;</span><span class="p">],</span> <span class="s1">&#39;green&#39;</span><span class="p">:[</span><span class="s1">&#39;&#39;</span><span class="p">],</span> <span class="s1">&#39;blue&#39;</span><span class="p">:[</span><span class="s1">&#39;0&#39;</span><span class="p">]}</span>
</pre></div>


<p>如果我们想要对于空值或者不存在的值统一返回默认值0，怎么处理比较好？</p>
<p>可以使用一行式表示，用or操作进行逻辑短路开关作用，但这样可读性很差：</p>
<div class="highlight"><pre><span></span><span class="n">red</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">my_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1"># or操作符的作用：如果or前半段为true的话，后面的逻辑不会再走</span>
</pre></div>


<p>也可以使用三元表达式来表示，提高可读性：</p>
<div class="highlight"><pre><span></span><span class="n">red</span> <span class="o">=</span> <span class="n">my_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">])</span>
<span class="n">red</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">red</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
</pre></div>


<p>所以可以总结成辅助函数了，如果频繁使用这种逻辑，就更应该抽出来封成函数：</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_first_int</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">found</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">found</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">found</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">found</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">found</span> <span class="o">=</span> <span class="n">default</span>
    <span class="k">return</span> <span class="n">found</span>

<span class="n">red</span> <span class="o">=</span> <span class="n">get_first_int</span><span class="p">(</span><span class="n">my_values</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
</pre></div>


<p>由此得到要点：</p>
<ul>
<li>开发者很容易过度运用Python的语法特性，从而写出那种特别复杂并且难以理解的单行表达式。</li>
<li>请把复杂的表达式移入辅助函数之中，如果要反复使用相同的逻辑，那就更应该这么做。</li>
<li>使用 if / else 表达式，要比用 or 或 and 这样的 Boolean 操作符写成的表达式更加清晰。</li>
</ul>
<h4>第5条：了解切割序列的办法</h4>
<p><strong>要点</strong>：</p>
<ul>
<li>不要写多余的代码：当start 索引为0，或end索引为序列长度时，应该将其省略；</li>
<li>切片操作不会计较start 与 end索引是否越界，这使得我们很容易就能从序列的前端或后端开始，对其进行范围固定的切片操作（如 a[:20] 与 a[-20:]）。</li>
<li>对list 赋值的时候，如果使用切片操作，就会把原列表中处在相关范围内的值替换成新值，即便它们的长度不同也依然可以替换。</li>
</ul>
<h4>第6条：在单次切片操作内，不要同时指定start，end 和 stride</h4>
<p><strong>要点：</strong></p>
<ul>
<li>既有start 和end， 又有stride 的切割操作，可能会令人费解。</li>
<li>尽量使用stride 为正数，且不带 start 或end 索引的切割操作。尽量避免用负数做stride。</li>
<li>在同一个切片操作内，不要同时使用start， end和 stride。如果确实需要执行这种操作，那就考虑将其拆解为两条赋值语句，其中一条做<strong>范围切割</strong>，另一条做<strong>步进切割</strong>，如果使用的开发程序对执行的时间或者内存用量的要求非常严格，以致不能采用两阶段切割法，那就请考虑使用内置的itertool模块中的 islice，创建的是迭代器。</li>
</ul>
<h4>第7条：用列表推导式来取代map和 filter</h4>
<p>列表推导式与map和filter之间的比较：</p>
<p>列表推导式：</p>
<div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">even_squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>


<p>map 和 filter函数的组合：</p>
<div class="highlight"><pre><span></span><span class="n">alt</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
</pre></div>


<p>可见：</p>
<ul>
<li>列表推导要比内置的map 和filter 函数清晰，因为它无需额外编写lambda 表达式；</li>
<li>列表推导可以跳过输入列表中的某些元素，如果改用map来做，那就必须辅以 filter 方能实现；</li>
<li>字典与集也支持推导表达式。</li>
</ul>
<h4>第8条：不要使用含有两个以上表达式的列表推导</h4>
<p><strong>要点：</strong></p>
<ul>
<li>列表推导支持多级循环，每一级循环也支持多项条件；</li>
<li>超过两个表达式的列表推导是很难理解的，应该尽量避免。在列表推导中，最好不要使用两个以上的表达式。可以使用两个条件，两个循环或一个条件搭配一个循环。如果要写的代码比这还复杂，那就应该使用普通的if 和for 语句，并编写辅助函数。</li>
</ul>
<h4>第9条：用生成器表达式来改写数据量较大的列表推导</h4>
<p>列表推导的缺点是：在推导过程中，对于输入序列中的每个值来说，可能都要创建仅含一项元素的全新列表。当输入的数据比较少时，不会出问题，但如果输入的数据非常多，那么可能会消耗大量内存，并导致程序崩溃。</p>
<p>例如：要读取一份文件并返回每行的字符数。若采用列表推导来做，则需把文件每一行的长度都保存在内存中。如果这个文件特别大，或是通过无休止的network socket （网络套接字）来读取，那么这种列表推导就会出问题。下面的这段列表推导代码，只适合处理少量的输入值：</p>
<div class="highlight"><pre><span></span><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/my_file.txt&#39;</span><span class="p">)]</span>
<span class="k">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span><span class="mi">86</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
</pre></div>


<p>为了解决此问题，Python 提供了生成器表达式，它是对列表推导和生成器的一种泛化。生成器表达式在运行的时候，并不会把整个输出序列都呈现出来，而是会估值为迭代器，这个迭代器每次可以根据生成器表达式产生一项数据。</p>
<p>把实现列表推导所用的那种写法放在一对圆括号中，就构成了生成器表达式。两者的区别在于，对生成器表达式求值的时候，它会立刻返回一个迭代器，而不会深入处理文件中的内容。</p>
<div class="highlight"><pre><span></span><span class="n">it</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/my_file.txt&#39;</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="o">&lt;</span><span class="n">genexpr</span><span class="o">&gt;</span> <span class="n">at</span> <span class="mh">0x101b81480</span><span class="o">&gt;</span>
</pre></div>


<p>以刚才返回的那个迭代器为参数，逐次调用内置的next函数，即可使其按照生成器表达式来输出下一个值。可以根据自己的需要，多次命令迭代器根据生成器表达式来生成新值，而不用担心内存用量激增。</p>
<div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="mi">100</span>
<span class="mi">57</span>
</pre></div>


<p>而且对于连锁的迭代器，外围的迭代器每次前进时，都会推动内部那个迭代器，这就产生了连锁效应，使得执行循环，评估条件表达式，对接输入输出等逻辑都组合在了一起。</p>
<p>把某个生成器表达式所返回的迭代器，可以逐次产生输出值，从而避免了内存用量问题。</p>
<p>如果要把多种手法组合起来，以操作大批量的输入数据，那最好是用生成器表达式来实现。只是要注意：由生成器表达式所返回的那个迭代器是有状态的，用过一轮之后，既不要反复使用了。</p>
<h4>第10条：尽量用 enumerate 取代 range</h4>
<p><strong>要点：</strong></p>
<ul>
<li>enumerate 函数提供了一种精简的写法，可以在遍历迭代器时获知每个元素的索引。</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">flavor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">flavor_list</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flavor</span><span class="p">))</span>

<span class="c1"># 对比使用range</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flavor_list</span><span class="p">)):</span>
    <span class="n">flavor</span> <span class="o">=</span> <span class="n">flavor_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flavor</span><span class="p">))</span>
</pre></div>


<ul>
<li>尽量用<code>enumerate</code>来改写那种将<code>range</code>与下标访问相结合的序列遍历代码。</li>
<li>可以给<code>enumerate</code>提供第二个参数，以指定开始计数时所用的值（默认为0）。</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">flavor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">flavor_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flavor</span><span class="p">))</span>
</pre></div>


<h4>第11条：用zip函数同时遍历两个迭代器</h4>
<p>例子：存在这样的两个迭代器，怎么求出最大长度的单词及其长度？</p>
<div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Cecilia&#39;</span><span class="p">,</span> <span class="s1">&#39;Lise&#39;</span><span class="p">,</span> <span class="s1">&#39;Marie&#39;</span><span class="p">]</span>
<span class="n">letters</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
</pre></div>


<p>下面有三种不同方法的对比：</p>
<div class="highlight"><pre><span></span><span class="c1"># 使用range</span>
<span class="n">longest_name</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">max_letters</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_letters</span><span class="p">:</span>
        <span class="n">longest_name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">max_letters</span> <span class="o">=</span> <span class="n">count</span>

 <span class="c1"># 使用enumerate</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_letters</span><span class="p">:</span>
        <span class="n">longest_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">max_letters</span> <span class="o">=</span> <span class="n">count</span>
<span class="c1"># 使用zip</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">letters</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_letters</span><span class="p">:</span>
        <span class="n">longest_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">max_letters</span> <span class="o">=</span> <span class="n">count</span>
</pre></div>


<p>可见，使用Python内置的<code>zip</code>函数，能够令代码变得更为简洁。</p>
<p><strong>要点：</strong></p>
<ul>
<li>内置的<code>zip</code>函数可以平行地遍历多个迭代器；</li>
<li>Python 3 中的<code>zip</code>函数相当于生成器，会在遍历过程中逐次产生元组，而Python 2 中的<code>zip</code>则是直接把这些元组完全生成好，并一次性地返回整份列表；</li>
<li>如果提供的迭代器长度不等，那么<code>zip</code>就会自动提前终止；</li>
<li><code>itertools</code>内置模块中的<code>zip_longest</code>函数可以平行地遍历多个迭代器，而不用在乎它们的长度是否相等。</li>
</ul>
<h4>第12条：不要在for 和while 循环后面写else 块</h4>
<p><strong>要点：</strong></p>
<ul>
<li>Python 有种特殊语法，可在<code>for</code>及<code>while</code>循环的内部语句块之后紧跟一个<code>else</code>块。</li>
<li>只有当整个循环主题都没遇到<code>break</code>语句时，循环后面的<code>else</code>块才会执行。（要遍历的序列为空时，也会立刻执行else区块）。</li>
<li>不要在循环后面使用<code>else</code>块，因为这种写法既不直观，又容易引人误解。</li>
</ul>
<p><strong>用途：</strong></p>
<p>如，判断某个区间的整数是否为质数：</p>
<div class="highlight"><pre><span></span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Testing&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Not coprime&#39;</span><span class="p">)</span>
        <span class="k">break</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Coprime&#39;</span><span class="p">)</span>
</pre></div>


<h4>第13条：合理利用 try/except/else/finally 结构中的每个代码块</h4>
<p>try/except/else/finally 的示例：</p>
<div class="highlight"><pre><span></span><span class="n">UNDEFINED</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">divide_json</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span>  <span class="c1"># May raise IOError</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">handle</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>  <span class="c1"># May raise UnicodeDecodeError</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># May raise ValueError</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="s1">&#39;numerator&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;denominator&#39;</span><span class="p">])</span>  <span class="c1"># May raise ZeroDivisiorError</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UNDEFINED</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">op</span><span class="p">[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="n">handle</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># May raise IOError</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># Always runs</span>
</pre></div>


<p>其中：</p>
<ul>
<li>无论<code>try</code>块是否发生异常，都可利用<code>try/finally</code>复合语句中的<code>finally</code>块来执行清理工作。</li>
<li><code>else</code>块可以用来缩减<code>try</code>块中的代码量，并把没有发生异常时所要执行的语句与<code>try/except</code>代码块隔开。如果<code>try</code>块没有发生异常，那么就执行<code>else</code>块。有了这种<code>else</code>块，我们可以尽量缩减<code>try</code>块内的代码量，使其更加易读。</li>
<li>顺利运行<code>try</code>块后，若想使某些操作能在<code>finally</code> 块的清理代码之前执行，则可将这些操作写到<code>else</code>块中。</li>
</ul>
      </div>
      <footer class="post-footer">
        <div class="meta">
          Article Categories: <a href="/category/python.html">python</a><br /> 
          Author Articles: <a href="/author/sysublackbear.html">sysublackbear</a><br />
          Article Tags:  #<a href="/tag/python.html">python</a>        </div>
      </footer>
      </article> <!-- /#page-main -->

        <aside id="page-side">
          <!-- begin includes/sidebar.html -->
          <nav>
            <h3>个人主页</h3>
            <ul>
              <li><a href="/categories.html">Categories</a></li>
              <li><a href="/archives.html">Archives</a></li>
              <li><a href="/tags.html">Tags</a></li>
            </ul>
          </nav>

          <nav>
            <h3>类别</h3>
            <ul>
              <li><a href="/category/about-me.html">about me</a></li>
              <li><a href="/category/c.html">C++</a></li>
              <li><a href="/category/code.html">code</a></li>
              <li><a href="/category/jia-gou-mo-shi.html">架构模式</a></li>
              <li><a href="/category/pelican.html">pelican</a></li>
              <li class="active"><a href="/category/python.html">python</a></li>
            </ul>
          </nav>

          <nav>
            <h3>链接</h3>
            <ul>
              <li><a href="https://www.zhihu.com/people/sysublackbear">知乎</a></li>
              <li><a href="http://www.cnblogs.com/sysu-blackbear">博客园</a></li>
              <li><a href="http://weibo.com/sysublackbear?is_all=1">新浪微博</a></li>
            </ul>
          </nav>
          <!-- end includes/sidebar.html --></aside> <!-- /#page-side -->
      </div>  <!-- /#page-body -->

      <footer id="page-foot">
        <p> Powered by <a href="http://pelican.readthedocs.org">Pelican</a></p>
      </footer>
    </div> <!-- /#page -->
  </body>
</html>